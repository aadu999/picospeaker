#!/usr/bin/python
### PicoSpeaker
### Written by Kyle
### A small program that speaks its command line using SVox Pico, soundtouch and Sox
### Speech rate, pitch, volume and language can be specified, and output can be saved to many file formats
### This program is free and unencumbered software released into the public domain. See UNLICENSE for details.
### SVox Pico, soundtouch and Sox are covered by their own open source licenses and copyrights,
### and are therefore not covered by the UNLICENSE included with PicoSpeaker.

from sys import argv, stdin, stderr, exit
from subprocess import call, PIPE
from os import environ as env, rename, remove

# help and version tuples
version = (
  'PicoSpeaker 0.6',
  'Written by Kyle',
  'This program is free and unencumbered software released into the public domain.',
  'See the included UNLICENSE file for details.')
help = (
  'Usage:',
  argv[0] + ' [options] <text>',
  '',
  'Options:',
  '-l|--language <language>	Language to speak: (default is en-US)',
  '-v|--volume <number>	Output volume: (default is 1.0)',
  '-r|--rate <number>	Rate of speech from -95 to 5000: (default is 0)',
  '-p|--pitch <number>	Voice pitch from -60 to 60: (default is 0)',
  '-o|--output <file>	Output to the specified file: (default is sound card output)',
  '-c|--compress|-q|--quality <number>	Compression/quality level of output file, depends on file type',
  '	This option causes an error if no output file is specified.',
  '-t|--type <type>	Save output file as <type>. Only needed if saving with a nonstandard extension.',
  '	This option causes an error if no output file is specified.',
  '-V|--version	Print version information',
  '-h|--help|-u|--usage	Print this help message')

# Spoken text is stored in temp files named using this list
temp = ['/tmp/picospeaker-', env['USER'], '-processed', '.wav']

def parse ():
  'Parse the command line and return settings and text to be spoken in a dictionary object'
  settings = {} #Voice parameters and command line options, the object returned by the function

  # The parser loop, which populates the settings object and handles usage and version options
  skip = False #set True to skip the next item in the sequence.
  for opt in range(1,len(argv)):
    if skip:
      skip = False
      continue
    if ( argv[opt] == '-V' ) or ( argv[opt] == '--version' ):
      for line in version: stderr.write(line + '\n')
      exit(0)
    elif ( argv[opt] == '-h' ) or ( argv[opt] == '--help' ) \
    or ( argv[opt] == '-u' ) or ( argv[opt] == '--usage' ):
      for line in version: stderr.write(line + '\n')
      stderr.write('\n')
      for line in help: stderr.write(line + '\n')
      exit(0)
    elif ( argv[opt] == '-l' ) or ( argv[opt] == '--language' ):
      languages = ('en-US', 'en-GB', 'de-DE', 'es-ES', 'fr-FR', 'it-IT')
      if ( argv[opt+1] in languages ):
        settings['language'] = argv[opt+1]
      else:
        stderr.write('Language ' + argv[opt+1] + ' is currently not available.\n')
        stderr.write('Available languages are ' + ', '.join(languages[:-1]) + ' and ' + languages[-1] + '.\n')
        exit(1)
      skip = True
      continue
    elif ( argv[opt] == '-p' ) or ( argv[opt] == '--pitch' ):
      try:
        if ( int(argv[opt+1]) in range(-60, 61) ):
          settings['pitch'] = argv[opt+1]
        else: raise ValueError
      except ValueError:
          stderr.write('Pitch must be a whole number from -60 to 60.\n')
          exit(1)
      skip = True
      continue
    elif ( argv[opt] == '-r' ) or ( argv[opt] == '--rate' ):
      try:
        if ( int(argv[opt+1]) in range(-95, 5001) ):
          settings['rate'] = argv[opt+1]
        else: raise ValueError
      except ValueError:
          stderr.write('Rate must be a whole number from -95 to 5000.\n')
          exit(1)
      skip = True
      continue
    elif ( argv[opt] == '-v' ) or ( argv[opt] == '--volume' ):
      try:
        float(argv[opt+1])
      except ValueError:
        stderr.write('Volume must be a number.\n')
        exit(1)
      settings['volume'] = argv[opt+1]
      skip = True
      continue
    elif ( argv[opt] == '-o' ) or ( argv[opt] == '--output' ):
      # TODO: Check for settings['filetype'] if output file extension would be unrecognized by Sox: may not be possible here
      settings['output'] = argv[opt+1]
      skip = True
      continue
    elif ( argv[opt] == '-c' ) or ( argv[opt] == '--compress' ) \
    or ( argv[opt] == '-q' ) or ( argv[opt] == '--quality' ):
      try:
        float(argv[opt+1]) #must be a number
      except ValueError:
        stderr.write('Compression/quality level must be a number.\n')
        exit(1)
      settings['compression'] = argv[opt+1]
      skip = True
      continue
    elif ( argv[opt] == '-t' ) or ( argv[opt] == '--type' ):
      settings['filetype'] = argv[opt+1]
      skip = True
      continue
    else:
      # First, die with an error if compression and/or type are set but no output file is specified
      if ( ( settings.has_key('compression') ) or ( settings.has_key('filetype') ) ) and not ( settings.has_key('output') ):
        stderr.write('You must specify the output file.\n')
        exit(1)
      # Now the text can be added to the settings object and the loop can be broken
      settings['text'] = ' '.join(argv[opt:])
      break
  return settings

def tts():
  'convert text to speech data and store it in a temporary file using the pico2wave utility from SVox Pico'
  command = ['pico2wave', '-w', ''.join(temp[:2]) + temp[-1]]
  if ( settings.has_key('language') ): command += ['-l', settings['language']]
  command.append(settings['text'])
  try: call(command)
  except OSError:
    stderr.write('FIXME: text is too large.\n')
    exit(1)

def voiceadjust():
  'Changes the pitch and/or rate of the speech'
  command = ['soundstretch', ''.join(temp[:2]) + temp[-1], ''.join(temp), '-speech']
  if ( settings.has_key('pitch') ): command.append('-pitch=' + settings['pitch'])
  if ( settings.has_key('rate') ): command.append('-tempo=' + settings['rate'])
  call(command, stderr=PIPE) #PIPE suppresses verbose output; it isn't blocking, so hopefully not a problem
  rename(''.join(temp), ''.join(temp[:2]) + temp[-1]) #effectively replaces the unprocessed speech with the processed speech

def speaker():
  'speaks the text, or saves it if an output file was specified on the command line'
  command = ['play', '-q']
  if ( settings.has_key('volume') ): command += ['-v', settings['volume']]
  command.append(''.join(temp[:2]) + temp[-1])
  if ( settings.has_key('output') ):
    command[0] = 'sox'
    del command[1]
    if ( settings.has_key('filetype') ): command += ['-t', settings['filetype']]
    if ( settings.has_key('compression') ): command += ['-C', settings['compression']]
    command.append(settings['output'])
    print 'Saving speech to ' + settings['output'] + '.'
  call(command)
  remove(''.join(temp[:2]) + temp[-1]) #all temp files have now been removed

try:
  settings = parse()
  if ( not settings.has_key('text') ):
    settings['text'] = stdin.read()
  tts()
  if ( settings.has_key('pitch') ) or ( settings.has_key('rate') ): voiceadjust()
  speaker()
except KeyboardInterrupt:
  stderr.write('Keyboard interrupt received. Cleaning up.\n')
  try: remove(''.join(temp))
  except OSError: pass # The file doesn't exist and therefore doesn't need to be removed
  try: remove(''.join(temp[:2]) + temp[-1])
  except OSError: pass # the file doesn't exist and therefore doesn't need to be removed
